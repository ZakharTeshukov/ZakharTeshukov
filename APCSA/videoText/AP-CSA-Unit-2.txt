hey all in this AP Computer Science a  video we're going to cover unit 2 using  objects if you don't like the pace of  the video adjust the playback speed in  YouTube check the timestamps to jump to  specific topics and check the video  description for other resources in this  video we'll learn how primitive types  are different than object types in Java  and why it matters you've probably  already learned that there are eight  primitive types in Java primitive types  are small simple pieces of data as an  example we create a primitive variable  int a and initialize it to three the  value for a is stored in the stack part  of memory the same thing happens when we  create a double variable and a Boolean  variable now let's create an object type  variable object types can also be called  reference types some common object data  types you may have heard of are string  array and scanner dog is an object type  that I've created unlike primitive types  you can design your own object type ypes  this is a common way to declare and  initialize an object type  variable primitive type variables have a  value stored on the stack object type  variables also have a value on the stack  but for object types the value is a  pointer the pointer points at a place in  Heap memory where the object is stored  Heap memory is larger than stack memory  so it can hold objects which are more  complex than primitive types let's  create another object type the objects  themselves are completely equivalent but  they have different identities because  they each exist in a unique part of the  Heap the two pointers are not equivalent  because they point to different places  on the Heap now let's declare a new  primitive variable D and assign it the  value of a d is created and we copy the  Stack's value for a and assign it to D  for data on the stack we don't think  about the identity because each variable  has its own unique value now let's  create a new dog type variable Z and  assign it the value of y z is created  and we copy the Stack's value for y and  assign it to Z notice that we copied the  pointer not the object when we set one  variable equal to another variable we  always copy the data on the stack but  Z's pointer and y's pointer have the  same value because they are pointing at  the same location on the Heap X's  pointer has a different value because  it's pointing to a different location on  the Heap now let's learn why these  differences are important look at these  three lines of code here we're using  double equals which is the equality  operator to compare A and B in Java the  equality operator compares the value on  the stack for two variables even though  A and B B are different data types Java  recognizes they are mathematically  equivalent and will evaluate to True  next we compare X and Y the stack data  for X and Y is their pointers the  pointers refer to different locations on  the Heap so they are not equivalent and  this expression evaluates to false there  are ways to check whether the objects X  and Y pointing at are equivalent in this  case they are however the proper way to  compare objects depends on the object  type and is never double equals finally  We compare y and z y and Z's pointers  have the same value because they are  pointing at the same location on the  Heap this expression evaluates to True  let's look at some other situations  suppose we change the value of the  Primitive D to 6 it's fairly  straightforward to see what happened and  now if we use the equality operator to  compare A and D it would evaluate to  false  now with object types there's two types  of changes we need to consider first we  can instruct the object that Y is  pointing at to change to Blue for now  don't worry about how we did that just  accept that it happened the change  affects both Y and Z because they are  both pointing at the same object for a  different type of change we can instruct  the Z variable to point at a different  object this doesn't affect Y at all  because Y is still pointing at the  original object whenever you are  modifying object types you need to  consider are you modifying the object  itself or are you modifying where the  variable is  pointing in this Java tutorial you'll  learn about using classes and creating  objects by the way an object is also  called an instance of a class or an  instance first let's talk about what an  object is in object-oriented programming  languages like Java objects have two  types of characteristics first they have  states which in Java we represent with  field variables second they have  behaviors that in Java we represent with  methods imagine a light bulb object two  states might be color and size three  behaviors might be flash turn off and  switch color let's create a light bulb  object this object has the value yellow  for the color field and the value five  for the size field if we call the flash  method it causes the object to behave in  a certain way now let's call the switch  color method you can see that the switch  color method changed the value of the  color field it's very common for  programmers to write methods to modify  the values of fields your next question  might be where did the code for the  object come from the answer is from a  Class A Class is like a blueprint or a  template for an object there are a  number of classes built into Java so  often we just use those pre-made classes  some some examples of pre-made classes  are the string class arrays class and  scanner class you've probably used at  least one of these already sometimes  programmers write their own classes  regardless once you have a class you can  use it to create as many objects as you  want anyway now that we've covered  classes and objects conceptually let's  learn how to create objects with code  here's how we can create an object for  the light bulb class we start by stating  the name of the class in this case light  bulb then a variable in this case X  followed by equals new lightbulb open  close parentheses semicolon what we did  is create a variable called X of type  light bulb and told it to point at a  newly created light bulb object now  let's look at another way to declare and  initialize a light bulb object on this  line we create a light bulb variable y  on the next line we create create the  light bulb object and tell why to point  at that object we're doing the same  thing but in the second example we split  up the steps we can't access an object  directly so we need a variable to allow  us to identify the object it's like how  people need names so we can identify  them let's look at a third example here  we declared a variable Z and initialized  it with a new light bulb object but  you'll also see an additional piece of  data anything inside the parentheses  gets passed to the Constructor and is  used in the creation of the object in  this case I pass the string green to the  Constructor which caused the light  bulb's color field to be set to Green  now you can't just pass anything you  want to a class's Constructor the  programmer of the light bulb class  determined what type of data The  Constructor could accept when working  with a class you need to know what type  of arguments you can pass to the  Constructor when making a new object  next let's talk more about fields we  learned earlier that in Java an object  states are managed by field variables  there are two types of fields you need  to know about the first are called class  variables because they belong to the  class these are also known as static  Fields the second are called instance  variables because they belong to the  individual instances these are also  called non-static Fields let's pull up  the light bulb class and some light bulb  instances again the light bulb class  defines color as an instance variable  that means each instance has its own  unique copy of the variable when we  change the value of color for the  instance that Y is pointing at it only  affects that one instance size is  defined as a class variable it belongs  to the class and is shared by all  instances of the class when we change  the value of a class variable it affects  the class and all instances of the class  when coding a class the programmer  decides which fields are class variables  and which are instance variables next  let's look at methods again there are  two types of methods static and  non-static methods first static methods  can be called from either the class or  an object while non-static methods can  only be called from an object to  understand better let's look at two  different methods in the light bulb  class the decreased size method is  static and the switch color method is  non-static let's write some code to see  how we can access the methods lightbulb.  decrease size decrease size is static  it's a behavior of the class so we can  call it from the class itself there  doesn't even need to be an object in  existence for us to call this method  alternatively we can create an instance  of the light bulb class it's legal to  call static method decrease size from  the variable Q because an object has a  class standing behind it however this  could be confusing to other programmers  reading our code you should make a  practice of calling static methods from  the class itself like above switch color  is a non-static method so we must call  it from an object the only variable we  have that is pointing at a light bulb  object is Q so we'll call it from Q as a  non-static method an object Behavior  switch color cannot be called from the  light bulb class this line of code will  give the error non-static method cannot  be referenced from a static context the  final thing to know is that static  methods can only access class variables  which are properties of the class  conversely non-static methods can access  class variables properties of the class  and instance variables properties of the  object this is why the switch color  method had to be non-static so it could  access and change the instance variable  color this fact will be important when  you learn about writing classes in a  later lesson before we end I wanted to  mention that there are a few classes  that have unique ways of creating  objects some examples include the string  class and the array class don't worry  about those now but be aware that  exceptions  exist in this lesson we'll learn about  calling methods in Java some important  points in object-oriented programming we  can think of methods as behaviors static  method methods are behaviors that belong  to the class so we call the methods from  the class itself a class is like a  blueprint for an object non-static  methods are behaviors that belong to  objects we need to use the class to  create one or more objects then we call  the non-static methods from a specific  object let's look at this cake class as  discussed earlier we can think of a  class as akin to a blueprint you might  expect the cake class as to have fields  and Constructors but we aren't  displaying them if you don't know what  fields and Constructors are yet that's  fine we only see the method headers the  method bodies don't matter to us because  we don't care how these methods do what  they do think of it like a car we don't  need to understand how a Car Works to  drive it let's look at the method  headers and learn what information we  can from them public is an access  modifier this means we can call the  method from either inside the cake class  or from another class compare that to  the private access modifier meaning the  other method can only be called from  inside the cake class next the static  keyword tells us this Behavior belongs  to the class itself we don't actually  need to make a cake to call list flavor  choices we can call the behavior from  the Cake's blueprint compare that to how  many calories which doesn't have the  word static as a non-static method it  must be called from a cake object  different cake objects will have  different numbers of calories so it  makes sense that this will be a  non-static method when I say that  different cakes may have different  numbers of calories this variability is  key to understanding why how many  calories is a non-static method since  each cake object could have different  ingredients the number of calories will  vary from one object to another that's  why the method needs to be called on a  specific cake object allowing us to  calculate the calorie content based on  the unique characteristics of that  individual cake this is our return type  it tells us that every time list flavor  choices is called it will send back a  piece of string data in the case of this  method we can surmise from the name that  The Returned string will be a list of  the different flavors of cake objects  that can be created from this class  return types can be primitive or object  types the how many calories method or  return a piece of data of int type add  writing has a void return type meaning  it will not return any data when called  here is the method name it should be in  lower camel case and describe what the  method does finally we have the  parentheses which can hold one or more  parameters parameters are variables that  receive data when we call the method  list flavor choices doesn't have any  parameters compare that to add writing  which has one string parameter every  time we call add writing we need to pass  it a string which will populate the word  variable new programmers often confuse  return types and parameters remember  parameters tell you what data needs to  be sent to a method when we call it  return types tell you what type of data  will be returned back now let's look at  the bakery class we'll write some code  in the main method of the bakery class  the main method is Auto automatically  called when we run a class for reference  I've included the method headers from  the cake class suppose we attempted to  call list flavor choices while this is a  valid method name in The Cake class  there is no method by this name in the  bakery class so Java can't find it let's  look at the cake methods and learn how  to call them from the bakery class list  flavor choices is a static method which  means it's a behavior that belongs to  the cake class itself to properly call  it from another class we will say cake.  list flavor choices which will run  without error let's go back and look at  the return type of the method it returns  a string we aren't doing anything with  the return data so the list of flavor  choices will disappear into the ether  let's print out the return string next  let's call the how many calories method  this method is nonstatic so it's a  behavior that belongs to the individual  objects to call it we need to create at  least one object we start by creating a  variable of type cake and name it  vanilla since vanilla is a variable of  an object type we will have to have it  point at something before we use it here  we create a new cake object and have the  vanilla variable point to it in memory  we have the vanilla variable which  points at a cake object the cake object  is an actual cake that we can do things  with contrast that that to the cake  class which is just a blueprint for a  cake we can make as many cake objects as  we want different cake objects may not  be identical but they must all follow  the specifications created by the class  blueprint how many calories has an INT  return type that means the method will  return the number of calories in a  particular cake as an INT again we are  just letting that data disappear into  the ether instead of printing it out  like before let's store the data in a  variable called calories next we want to  call the ad writing method it is a  non-static method so we must call the  behavior from an object it has a void  return type so no data is returned the  ad writing method has a string parameter  that means when we call AD writing we  need to pass a string argument the  argument we pass will populate the  word's parameter affecting how the ad  writing method behaves when we call the  ad writing method it modifies the object  some methods modify objects While others  don't finally let's look at the mix  ingredients method this method has a  private access modifier meaning it can  only be called from inside the cake  class there is no way for us to directly  call mix ingredients from the bakery  class however if one of the public  methods we called happens to call the  mix ingredients method as part of its  workings we would have indirectly called  mix ingredients before we wrap up let's  quickly recap what we've covered in this  lesson we learn that methods in Java can  be thought of as behaviors with static  methods belonging to the class itself  and non-static methods belonging to the  individual objects we explored how  static methods like list flavor choices  can be called directly from the class  while non-static methods like how many  calories require an object to be created  first we also discussed method headers  including access modifiers return types  method names and parameters and how they  tell us important information about what  a method does and how to use  it welcome in this Java tutorial we'll  learn how to use the string class some  important facts to know string is a data  type that holds text internally strings  are an array of the primitive type care  the string class has a variety of  methods to compare and modify strings  we'll start by looking at the most  common way to declare and initialize a  string which is to say string the name  of the variable in this case a and then  set it to a string literal in this case  Hello Java will place the variable on  the stack and create a pointer pointing  to the object on the Heap typically it  will put it inside the string pool this  means if we create another string  variable with the same value Java will  look in the string pool see it's already  there and then have the new variable  point at the same memory location this  Behavior reduces memory usage this  behavior is different from most other  object types in Java now let's look at a  less common way to declare and  initialize a string variable this is how  we declare and initialize most objects  when we do it this way Java will create  a unique object outside of of the string  pool if we do it again this way even if  it's the same value it will create a  second object on a different part of the  Heap while this is unusual behavior for  a string this is typical for most  objects now let's look at this line of  code for this lesson sop stands for  system out print line a equals B checks  if the variables have the same data  stored on the stack for primitive types  like int or Boolean double equals works  well because all of the data is stored  on the stack however with object types  like strings double equals checks if the  pointers on the stack are pointing at  the same location on the Heap in this  case A and B point to the same memory  location so it will evaluate to true now  let's look at another line of code we're  checking if C and D are pointing at the  same memory location on the Heap they  aren't so even though the data itself is  the same it will evaluate to false  because the the variable's point at  objects in different physical locations  these two objects while equivalent have  different identities checking if two  variables or pointing at the same memory  location is called referential equality  and is why double equals isn't a good  way to compare objects in the case of  strings it will generally work but it is  a risky practice for Strings We compare  equality using the equals method so a  equals B compares is the data that A and  B point to in this case A and B are  pointing at the same block of data so  they will of course be equal C and D are  pointing to different memory locations  but the data in those memory locations  is the same so the equals method will  return true let's look at another way to  use the string class's equals method  here we're calling the equals method  from the string object that a is  pointing at we're passing the string  literal hello to the method since a is  pointing at a string object that is  equal to the string literal we passing  the method will return true next let's  change a this created a new object in  the string pool and changed A to point  at that new object the original object  is unchanged we didn't modify the object  we created a brand new object and  changed where a was pointing in fact  unlike most objects strings are mutable  that means once they are created on the  Heap they can't be modified people often  get confused because it seems we have  modified the string a is pointing at but  really we just created a new string  let's look at some other examples to see  how strings are handled in memory we  created the E variable on the stack and  have it point to a new object in the  string pool next we create a new  variable F and copy the data from e in  the case of a primitive data type we  would copy the actual value for object  types like string we copy the pointer so  both variables are pointing at the same  object in Heap memory this would happen  even if the string weren't in the string  pool next we create a variable G on the  stack and have it point at a new object  in the string pool finally we create a  fourth variable H and have it point at a  newly created object Capital hi on the  Heap now let's look at some comparisons  eals F checks if the two variables point  at objects with the same value E and F  point at the same object so naturally  that object has the same value as itself  and the method returns true next we  check e equal H even though e and H both  point at objects that say high the  strings equals method is case sensitive  so it returns false finally we use the  equals ignore case method to compare e  and H ignoring the capitalization e and  H point at objects with the same value  so the equals ignore case method returns  true it's important to know that even  though all object types have an equals  method many objects equals method only  checks referential equality so their  equals method behaves like double equals  now let's look at some other useful  methods in the string class here we call  the length method the length method  counts the number of characters in the  string and returns it as an INT G is  pointing to howdy so length will return  five next we have the substring method  which copies a part of the string and  returns that part as a new string the  original string the variable is pointing  at will be unchanged we saw that when  calculating a String's length we start  counting at one but when using the  substring method we start counting at  zero for a string with length five the  indexes go from 0 to four in this  example we passed one argument to the  substring method the substring method  will start at index 2 inclusive and go  to the end of the original string this  call Returns the substring  wdy there's another version of the  substring method with two parameters so  we provide it with two arguments in this  case the first argument is where we want  to start and the second one is where we  want to stop however you must be careful  because the first value is inclusive  while the second one is exclusive we  start at index one but we'll end one  before index 4 this call Returns the  substring O  WD let's look at the compare two method  the compare two method in the string  class compares the two strings lexor  graphically and returns an INT of their  difference if the two strings have the  same value it will return zero in this  case it returns -32 if we switch the  order of H and E it would return  positive 32 finally let's look at a  couple of examples of how we might use  these methods here we're taking the  length of the string H is pointing at  and storing it in an INT value I notice  that since I is a primitive type all the  data is on the stack here we check if E  equals the string literal Pi in this  case it returns false so the code in the  curly brackets doesn't get executed the  string class has many other useful  methods you can read about in the  documentation Linked In the video  description in this lesson we'll learn  about the two uses for the plus sign in  Java some important facts to know the  plus sign in Java has two functions  first mathematical addition second  concatenation which takes two strings  and combines them into one longer string  in some cases Java will automatically  convert different data types to allow  them to be combined these rules are Java  specific and may differ in other  language languages let's take a look at  this Expression 3 + 5 we're adding 2 ins  so it's going to evaluate to the int 8  now let's look at 2.0 + 4.0 these are  doubles so it's going to evaluate to the  double 6.0 in this example we're adding  the double 4.2 and the int 3 to avoid  loss of precision Java automatically  converts the int to a double and we're  going to end up with a double  7.2 here's an example of how we might  use the original expression in a full  line of code a a = 4.2 + 3 now we're  going to look at a different operation  string concatenation many languages like  Java also use the plus sign for  concatenation here's an example of using  the plus symbol with two strings Java  combines these two strings into a longer  string hi there now let's look at this  expression the first operand is a string  and the second operand is an INT Java  recognizes that it can't perform  addition here so it implicitly converts  the int 8 to a string now it  concatenates the two strings into the  string great here's an example that  shows the importance of operator  precedence the plus operator is left  associative so we'll execute from left  to right 8 + 9 is 17 17 is implicitly  converted to a string and the two  strings are concatenated into the string  17 years old in this variation we add a  set of parentheses parentheses have the  highest precedence so we start with the  second plus symbol the nine is  implicitly converted to a string and  concatenated with the second string next  eight is implicitly converted to a  string and concatenated into the string  89 years  old in this lesson we're going to learn  about the math class in Java some  important facts to know the math class  in Java contains methods that perform  various mathematical functions all  methods in the math class are static so  we can call methods directly from the  class for example math.random you can't  extend or create an instance of the math  class math ABS this method calculates  the absolute value of a number we can  pass the ABS method an INT a double a  float or a long the ABS method will  always return the same data type as what  it was passed here's an example if we  pass math ABS the double -3.2 it will  return the double 3.2 to math po this  method calculates exponents for example  5 to 4th power math po can be passed a  combination of two inss doubles Floats  or Longs math pow always returns a  double for example if we pass the int 3  and the double 2.0 it calculates 3 to  the 2 power and will return 9.0 math  square root this method calculates the  square root the square root method can  be passed an INT a a double a float or a  long math square root will always return  a double for example if we call math  square root and pass at the int n it  will return the double 3.0 math Pi  notice that there are no parentheses  after Pi unlike the previous examples  which were methods Pi is a public field  variable that we are accessing from the  math class most field variables we use  are private so we can't access them this  way from outside the class math Pi is a  double variable that is approximately  equal to the mathematical constant Pi  for example we might use it in the  expression circumference equals 2 * math  Pi * radius there are a variety of other  useful methods in the math class to see  them all go to a search engine type in  Java the current version number of java  and math you will find a document  detailing the math class including all  the methods and their variations what  type of data we can pass to the methods  and what type of data the methods will  return you've reached the end and if you  have a test coming up good luck tell me  in the comments if there was something  in the video that you found useful check  out the other resources in the video  description and on the channel and I'll  see you soon