hello welcome to the new ap computer  science a series  unit 5 on writing classes  if you want to jump ahead to a specific  topic check out the time markers in the  video description  also i will be adding to and updating  this series so make sure to hit the  subscribe button to keep up to date on  all the latest content  we'll start this unit by learning the  basics of writing classes and using  objects  in place of the term object i may say  instance of a class or instance  all mean the same thing  the example of languages that use an  object-oriented paradigm java c-plus  plus c sharp and python there's many  more but these are four major ones  so what is an object in object-oriented  programming objects have the following  they have states and we do that with  fields in java and they have behaviors  and we do that with methods in java  so let's take an example of a real world  object that we might want to represent  in programming so this dog has states  color  is it awake  and its age and the dog also has  behaviors  like bark  run  and eat the states would be represented  by fields the behaviors would be  represented by methods  what is a class a class is a blueprint  or a template for an object  so i use this picture as an example this  is not an actual car but it's a  blueprint or a template for the car  now there are certain behaviors in java  that we can access without creating the  object we can do it simply from the  class and these are static methods in  java and we know their static methods we  say have the word static there for  example we can rotate the wheel in this  blueprint we can open the hood in this  blueprint that's why these are static  methods we don't need to create the  actual car to use them though we could  use them on an actual car  now non-static methods these are  behaviors that we can only access from  an object  in java we call these non-static methods  and they don't have the word static so  that lets us know they're non-static  methods  if we want to turn on the engine we  actually have to create a car from the  blueprint we have to create an instance  of the class same thing with drive we  have to create an instance of the class  and apply drive method to it  right so let's talk about class  variables now these are static fields  and these are states that belong to the  class in java we call these class  variables or sometimes static fields  understand if you change a class  variable anywhere you change it  everywhere so if we change the wheel  size anywhere in any instance or the  class itself it'll change all instances  so if we change the wheel size in one  place  since the wheel size belongs to the  class it changes it everywhere same  thing with vehicle type we change it one  place it gets changed everywhere  we also have instance variables and  these instance variables also called  non-static fields we can't give them an  actual value they don't have an actual  value until we create an instance of the  class so we can lay out what their value  will be but we can't access that value  until we create the instance so in java  we call these instance value variables  also known as non-static fields  only an object may have a value for the  instance variables though like i said we  can set out what the value will become  in the  class  and changing the values in one object  does not affect other objects so here's  an example of some instance variables  they don't have the word statics we know  their instance variables color and  license plate and if we change these in  one place they only change for that  particular instance  so additional notes  a static method can only access class  variables  a non-static method can access class  variables or instance variables  and you notice we have the private  keyword on our fields what that does is  that makes it so the fields can't  directly be accessed by other classes it  helps us prevent bugs and it also helps  us get a top score on an ap free  response question  here is some sample class code  so for our class audi a8  we've got private static int wheel size  this is a class variable it be belongs  to the class  there's an instance variable it belongs  to the instance private string color  then we have some methods i didn't  actually put the code inside it to save  space  private static void rotate wheel this is  a static method so we don't have to  create an instance to use this  we've got public void turn on engine  this is a non-static method we can only  call this from an instance  and then there's going to be some getter  and setter methods that are not shown  right here's some more sample code about  how we might use the audi a8 class  so we've got our main method here i'm  calling rotate wheel i'm calling it from  the class this is legal to do because  rotate wheel is a static method  here i'm declaring a new variable called  jane's car the variable is of type audi  a8 and we're creating a new object and  jane's car has a pointer that's pointing  at that new object  then we're calling jane's car rotate  wheel even though rotate wheel is a  static method we can still call it from  an instance  and then we're also calling start engine  start engine is a non-static method so  we can only call this from an instance  some additional notes  the private static in wheel size is a  class variable private string color is  an instance variable and we know that  because static means it's a class  variable no mention of static means it's  an instance variable  if we make a change to wheel size since  it is a class variable it will change  the value everywhere  and if we make a change to color which  is an instance variable it will only  change the value in one instance  that concludes a basic overview of what  classes are and what objects are in java  now let's talk about declaring methods  here's a sample method  first up here we have the method header  and then we have the curly brackets that  show us where the method body begins and  ends  let's take a look at the method header  the first part is the axis modifier  the two most common access modifiers in  java are public and private  public means we can access it from  inside or outside the class while  private just means we can only call it  from inside the class  next we have this where it says static  now a method can be static or non-static  if it's non-static we just leave this  part here blank we'll learn more at  another time what it means to be static  or non-static but the two key things are  whether a method is static or non-static  controls what fields the method can  access and also how the method can be  called  next we have the return type here so we  could have a void return type which  means the method returns nothing and if  it's a void return type that means the  return statement's optional a return  statement in a void return type method  will just end the method early  now there's a number of other  possibilities any primitive or any  object type could be the return type  and that just means we have to make sure  that when the method ends it returns a  piece of data of the proper type  next we have the method name here  a method in java should be descriptive  of what it does  and it also should be written in lower  camel case  and then here we have the parameters now  we don't need to have parameters it  could just be a simple open closing  parentheses  we can have one parameter we can have  multiple parameters the purpose of the  parameters are to pass data to a method  so if we call sample method we have to  pass it one int followed by one string  and those pieces of data will go into  the variables x and y respectively  when we have multiple parameters we need  a comma separating them  you may notice that there's two  different places people put the opening  curly bracket this here where it opens  on the next line is part of the almond  indentation style  whereas when the opening curly bracket  is on the same line as the declaration  that's part of the knr indentation style  so there you have the basics of  declaring a method in java in this java  tutorial we're going to be learning  about getter methods and setter methods  these are also called accessor methods  and mutator methods respectively  in this video we're going to learn about  four things  first we're going to review field  variables  second we're going to discuss the reason  for having getter and center methods  third we're going to learn how to write  getter and setter methods  and finally we're going to see getter  and center methods working in a live  code demonstration  here we have a class student  with two fields  the first one student id is an instance  variable also known as a non-static  field and we know it's non-static  because it doesn't have the word static  here  now instance variables can have a  different value for each instance of  student and that's what we want because  the student id should have a different  value for each student  down here we have a static field also  known as a class variable and we know  it's a static field because it says  static here  now this value mascot since it's a class  variable will have the same value across  all instances of student  this variable belongs to the class now  we can change the value but it changes  it everywhere  you'll notice that we haven't set a  value for either of these variables  with local variables we'd have to give  it a value before we accessed it but  fields will set their own values if we  don't set it for them  so this one is an int so it'll  automatically default to zero this one's  a string a string is a type of object  and all object fields will default to  null  these are marked private and what that  means is that we can access these fields  inside the student class but we can't  access them outside the student class  directly  now we do this because it makes it  harder to accidentally change the value  but it means we need to have an indirect  way to access them from another class  and we do that using getter and setter  methods so let's create our first getter  method  you see we've named it get student id  because student id  is the field we are trying to return the  value of  it's got a return type of int the return  type has to be the same as the data type  of the field we're trying to get  non-static fields like student id can  only be accessed by non-static methods  so we have to make sure git student id  is non-static we know git student id is  non-static because it doesn't have the  word static in the method declaration  and we make it public so we can access  it from other classes  next we'll create a setter method this  one is going to be set student id  we have to pass the value and we're  going to use that value to change the  value of the field student id so i've  called my new student id you can call it  whatever you want of course this  parameter has to be the same data type  as the field  it's a void method because we're not  returning anything  and again it's very simple we're just  setting the field student id  equal to our parameter new student id  now let's make a getter for the mascot  field  so mascot is a static field so  traditionally we make getters and  setters for static field static we  wouldn't have to but it makes it a  little easier to access so we're going  to again say public static  mascot is a string so we're returning a  string and we're saying get mascot and  all we do is say return the value of the  mascot variable  next we'll make a center method for  mascot  so we'll say public static  it's a void method because we're not  returning anything we're going to call  it set mascot  and we need to pass it a new value so  we're making a parameter string  new mascot  and we're setting the mascot field equal  to the parameter new mascot  next let's compress this all down so we  have a little more room  so here we've still got our fields we've  got our methods here though we've hidden  the bodies just so we have this room  here  now we're going to add a second class  the high school class this would have to  be in a different file but for  illustrative purposes we're going to  have it on the same screen  we're going to add a stack and a heap so  we can trace exactly what's going on in  memory if you want to learn more about  how stacks and heaps work with variables  and objects please click on the video in  the upper right hand corner of the  screen  next we're going to add a main method to  our high school class  and then our first line of code is we're  going to declare a student priya  and have it pointed a new student so  we're going to put the reference  variable priya on the stack that's going  to point to a new student object on the  heap  so you can see the instance variables  are in the instance of the student class  here student id this defaulted to zero  because int fields default to zero if we  don't give them a value  and we notice our class variable we've  got up here and that's because we only  have one copy of the class variable so  we're going to keep it separate  and the class variable is mascot and  since mascot is a string which is an  object  objects always default to null if we  don't give them a value  next we're going to declare a new  student variable andre and have it point  at a new instance of the student class  so we've added a new instance here and  again it's got its own copy of the  instance variable student id  next we're going to call the set mascot  method  from the andre instance variable  now set mascot is a static method so  that means we could call it from andre  we could call it from priya or since  it's a static method we could actually  call it from the class itself student so  we change the value of the mascot field  to duke  next  we're going to call andre.set student id  set student id  is a non-static method so we would have  to call it from an instance we'd have to  call it from either andre or priya so  we're going to set the student id  of the object andre is pointing at to 1  2 3 4 5.  next we're going to create a variable  int andre id on the stack and we're  going to set it equal to  whatever gets returned when we call get  student id from the object andre is  pointing at so andre is pointing at an  object with a value of one two three  four five for student id so we're going  to end up setting andre id equal to one  two three four five  next we're gonna do the same thing with  the priya  so int priya id equals whatever was  returned when we call get student id  from the object priya is pointing at so  the student id for the object pre is  pointing out to zero so we're going to  set pre id equal to zero  here we're going to system out print  line whatever gets returned when we call  get mascot from andre so it doesn't  really matter where we call get mascot  from biscuit mascot is always going to  return  the class variable mascot and that's  going to equal duke for wherever we call  it from so this is going to print out  duke  next we're going to system out print  line get mascot when we call it from the  student class git mascot as we said  before is a static method so we can call  it from an instance or from the class  itself so get mascot will again return  the value of the class variable mascot  which is duke so this will again print  out duke  so there you have an example of tracing  some getter and setter methods and  seeing how it behaves in memory  next you're going to learn about  overloading methods  overloaded methods are methods that have  the same name in the same class  three important things to know about  overloading methods first overloaded  methods must have exactly the same name  second overloaded methods must have  different number  and or types of parameters  third constructors can also be  overloaded  let's talk about the things that  overloaded methods can't have different  what they can have different and what  they must have different  overloaded methods can't have different  method names  occasionally a program will make an  error and they will unintentionally give  two message different names  the methods will not be overloaded in  this case  overloaded methods can have different  return types from each other  overloaded methods can have different  visibility one could be public one could  be private  overloaded methods could have different  static or non-static values  finally overloaded methods could have  different parameter names  the java compiler needs to know which  method is being called so one of the  three things must be different  first the number of parameters  or the type of parameters  or the order of the type of parameters  for example one method could have a  string followed by an int the other  could have an int followed by a string  let's look at some examples  we have three overloaded methods here  output answer has no parameters  this output answer has one int parameter  this output answer has two end  parameters  when we call output answer from the main  method we have one int argument the  compiler will use this to match it up to  the appropriate method  here it is  let's look at another example  we have three versions of calculate  answer  the first one has one in parameter  the second one has one double parameter  the third one has one string parameter  when we call calculate answer we have  one double argument the compiler will  use this to match it up to the correct  version of calculate answer right here  let's look at a third example  we have two different versions of  compute answer  the first one has an int followed by a  double  the second one has a double followed by  an int  this called a compute answer will look  for one that has a double  followed by an int  right here  here's an example of two overloaded  methods that have a lot of differences  first one is public the other is private  the first is static the second is  non-static  the first has the void return the second  has an end return  and finally the first has a parameter a  the second has a parameter z  this is all fine however there's a  problem  both have one boolean parameter  this means when we call solve for answer  with one boolean argument the compiler  won't know which version of solve for  answer we want  let's correct this  the second one we're going to change  from boolean to ins now we have one  solve for answer with a boolean  parameter and another with an int  parameter  now when we call solve for answer with  one boolean argument it knows which one  to go to  next we're going to talk about  constructors in java  so what is a constructor  a constructor is sort of like a special  type of non-static method  that only runs when you first create an  instance of a class an instance of a  class is also known as an object  so when you create an object the  constructor runs and the purpose of it  is to set up the new object  so let's look at this example we've got  a class robot and a class space station  we have a class variable fuel source and  an instance variable name  we have our constructor here a  constructor will have the word public  then the name of the class then  parentheses that may have nothing inside  or may have parameters  so the first thing that happens is we  set the field fuel source equal to  electricity  the next thing we're doing in this  example is calling a method we can call  a method from constructors random name  so what does random name do in this case  it just generates a random number from  one to three  and sets the name field to either bender  hal 9000 or gork based on whether this  is one two or three  okay let's look over at space station in  our main method we declare a variable of  type robot called 1 then we create a new  instance of robot so we'll set fuel  source equal electricity and we'll  generate a random name and put it in the  name field  same thing with our variable 2 and our  variable 3.  okay next let's look at a  situation where we have overloaded  constructors what overloaded  constructors are is we have two or more  constructors and the compiler  differentiates them because they have  different parameters  now in our example here  under factory we create a new variable  called rot1 of type robot2  and then we create a new instance of  robot2 and we pass the string r2d2  now the compiler looks and says okay  we've got one argument and it's a string  so we have to find a constructor that  has one argument that's a string and  here's a constructor right here  so what it does it says fuel source  equal to electricity  and then it takes the string that we  passed in new name and sets our name  field equal to the value of the new name  parameter  now let's look at the second one we've  got a variable named two of type robot2  we make a new instance of robot2 but we  have no arguments here so it's going to  go to the constructor with no parameters  now this is an example of using the this  command  and what that does is in this situation  this is going to call another  constructor  so it's looking for a constructor that  has one string parameter so it goes to  this one it passes the string wall-e  so it'll set fuel source equal  electricity and they'll set name equal  to  new name which happened to equal wall-e  in this case  so let's look at another example where  we can run into a problem overloading  constructors  so now we have a class called robot  confused and we have a class called  alien planet  we've got our two fields  and we've got two constructors now these  constructors both have two strings the  strings have different names in the  parameters but it's two strings this is  a problem because when we want to create  an instance  we're passing two strings  our compiler doesn't know do we want to  use this constructor or this constructor  it could legitimately be either  robot confused won't even build because  when the compiler tries to create an  instance it's not going to be able to  know which constructor we want to use  let's look at one more situation  so we have a class robot 3.  now robot 3 has no constructor at all  only in situations where a class has no  constructor at all  java will build us a very basic no  parameter constructor  here when we declare a variable  1 of type robot 3 and have it pointed a  new instance of robot 3.  since there's no arguments here it'll  call this very basic  no parameter constructor it wrote for us  but it'll only do this if there's no  other constructors that we've written  and again it's going to be a no  parameter constructor so we can't pass  any arguments when we create a new  instance of it  now you can see here since it's a basic  constructor it's not initializing fuel  source or name  now fields will automatically initialize  themselves if we don't initialize them  and it depends on what type of field  they are these are string fields and  strings are a type of object so object  fields if they're not initialized will  always initialize to null this is legal  in this particular case because java  created this constructor for us  next you'll learn about the this keyword  in java so what is this  this contains a pointer to whatever  object this is currently in  this even though it acts kind of like a  variable it does not need to be declared  also this can only be used in either  non-static methods or constructors  so let's look at it we've got a heap  here and let's say we've just got some  random object on the heap and inside  that random object we've got these two  variables string x which points to  another object on the heap  int array y which points to another  object on the heap  and this which points right back around  to the original object  so there's three main uses for this  number one to specify a field over  another variable of the same name  two to call another constructor in the  same class  and three to pass a copy of a pointer  reference back to the current class so  let's take a look at these three uses  individually  so first to specify a field now i've  created a couple of fields one's static  one's non-static  and then i've created some methods now  let's look at the print x method you  notice i've got a local variable with  the same name as the field this is legal  however when we tell it to access x  it is going to give the local variable  precedence  now let's look at another example let's  say we have a setter method so we're  accepting a parameter x and again we  have a field with the same name  well we want to change the field to the  parameters value  so to specify when we're talking about  the field we say this  so we're talking about this object dot x  equals  the parameter x  same thing here y  we're creating a local variable y  and we're saying this y as in the field  equals y the local variable  second use is to call another  constructor in the same class  so we've got this first constructor here  then we have this  and we're calling this other constructor  here  if we use it in this sense  this must be the first line in the  constructor  and the third is to pass a pointer  reference back to the current object  so we made a random class we'll call it  this keyword three  the first thing we do in the main method  is we created an instance of this  keyword three we called it an object and  we set that to equal new keyword three  so an object is a  new instance of keyword three  so what happens is we  have a new object  then since we've created this new object  this also caused this instance variable  to be created which is a different class  called sum class  and the name of the variable is another  object and that points to a new instance  sum class so what happens there  is our variable another object points to  an instance of some class  now we're calling method two from  the instance and object  and we go to method two and what this is  doing is this is calling  a method called some method in the  instance another object and is passing  this and this being the pointer  back to the original object  so we passed it  and this new object created a variable  that points right back to the original  object  next you're going to learn about scope  and lifetime of variables  what is scope and lifetime  scope determines where in a program that  a variable can be accessed  lifetime determines when a variable or  object is created and when it is  destroyed in memory  the scope and lifetime of a variable is  determined by where it is declared not  where it is initialized sometimes we  declare and initialize variables on the  same line sometimes we don't  let's take a look at this class  we have our main method here and we have  four variables a b c and d a b c and d  are all local variables because they are  local to this method  int a is declared here at the top of the  method  and its scope is anywhere inside this  method and its lifetime is from where it  is declared until the end of the method  int b is declared inside this block of  code here so it's created when this  block of code runs and it's destroyed  when this block of code completes  here we have in c  that is declared as part of this for  loop  c is declared when we begin the for loop  and it is not destroyed until all cycles  of the for loop are complete  into d is created inside this block of  code that's part of the for loop  empty is created every time we run a  cycle of the for loop and is destroyed  every time we end that cycle then it's  recreated again when we run the cycle  again  let's take a look at this other class  we have a main method and we have  another method  we're going to start tracing it out  so we're going to declare a then  initialize a so that puts a and its  value 3 on the stack here  now we're going to call another method  and when another method runs it'll run  this code inside  notice a becomes grayed out that's  because a is out of scope  it's not available in another method  since local variables are only available  in the methods where they are created  however it still exists on the stack so  the data is there it's just not  accessible right here  we finish up another method and then  we're back to our main method  now we see a is now back in scope  finally we end the main method  so a is destroyed and removed from the  stack  next let's take a look at this class  we'll start by looking at method two  method two has a parameter called name  parameters are variables that are  defined in the method declaration we  have to pass a value to them any time we  call the method  parameters are created when the method  runs  and their scope is anywhere inside the  method  their lifetime begins when the method is  first called and ends when the method  call is complete  now let's take a look at this class  variable here  class variables are also known as static  fields  and we declare them as static when we  create the variables  class variables are created the first  time we use the class or we create an  instance of the class  class variables are accessible in all  static or non-static methods in the  entire class  the class and all instances of the class  share one value for each class variable  so if you change it one place you change  the value everywhere  now let's take a look at this instance  variable here  instance variables which are also known  as non-static fields do not have the  word static in their declaration  there is a different copy of every  instance variable in every instance that  we create of a class so if we create  five instances of the scope and lifetime  class there'll be five separate copies  of the b instance variable and they may  each have their own values  instance variables are created when an  instance of the class is created and  destroyed when that instance is  destroyed  they are only accessible in non-static  methods so we can tell this is a  non-static method because it doesn't  have this word static there  this method is static so we can't access  instance variables that covers scope and  lifetime of variables and concludes our  topics on unit 5. thanks for watching  please hit the like button and then  leave me a comment down below  to see the next video click on the image  on the left side of the screen to see  the entire playlist for the series click  on the image on the right side of the  screen and to keep up to date on all the  latest content hit the subscribe button  in the middle